#!/usr/bin/env python3
"""
TTF to Embeddable C/C++ Header Converter

This script converts all .ttf font files in a specified directory
into a single embeddable C/C++ header file for use with Dear ImGui.

Usage:
    python ttf_to_header.py [--input <fonts_dir>] [--output <output_header.h>]

Example:
    python ttf_to_header.py --input ../fonts --output ../ui/embedded_fonts.h
"""

import os
import argparse
from pathlib import Path


def ttf_to_c_array(file_path: Path) -> tuple[str, list[int]]:
    """
    Read a TTF file and convert it to a C array of unsigned char.
    
    Args:
        file_path: Path to the TTF file
        
    Returns:
        Tuple of (variable_name, byte_array)
    """
    with open(file_path, 'rb') as f:
        data = f.read()
    
    # Create variable name from filename (sanitize for C)
    var_name = file_path.stem.replace('-', '_').replace(' ', '_')
    var_name = f"font_data_{var_name}"
    
    return var_name, list(data)


def generate_header(fonts_dir: Path, output_file: Path, namespace: str = "EmbeddedFonts"):
    """
    Generate a C/C++ header file containing all TTF fonts as embedded data.
    
    Args:
        fonts_dir: Directory containing TTF files
        output_file: Output header file path
        namespace: C++ namespace to use
    """
    ttf_files = sorted(fonts_dir.glob("*.ttf"))
    
    if not ttf_files:
        print(f"No TTF files found in {fonts_dir}")
        return
    
    lines = []
    lines.append("// Auto-generated by ttf_to_header.py")
    lines.append("// DO NOT EDIT MANUALLY")
    lines.append("")
    lines.append("#ifndef EMBEDDED_FONTS_H")
    lines.append("#define EMBEDDED_FONTS_H")
    lines.append("")
    lines.append("#include <cstdint>")
    lines.append("#include <cstddef>")
    lines.append("")
    lines.append(f"namespace {namespace}")
    lines.append("{")
    
    font_entries = []
    
    for ttf_file in ttf_files:
        var_name, byte_data = ttf_to_c_array(ttf_file)
        font_name = ttf_file.stem
        
        print(f"Processing: {ttf_file.name} ({len(byte_data)} bytes)")
        
        # Generate the array
        lines.append(f"    // Font: {font_name}")
        lines.append(f"    // Size: {len(byte_data)} bytes")
        lines.append(f"    static const unsigned char {var_name}[] = {{")
        
        # Format bytes with proper indentation
        bytes_per_line = 16
        for i in range(0, len(byte_data), bytes_per_line):
            chunk = byte_data[i:i + bytes_per_line]
            hex_values = ", ".join(f"0x{b:02x}" for b in chunk)
            if i + bytes_per_line < len(byte_data):
                hex_values += ","
            lines.append(f"        {hex_values}")
        
        lines.append("    };")
        lines.append("")
        
        # Store entry info
        font_entries.append({
            'name': font_name,
            'var_name': var_name,
            'size': len(byte_data)
        })
    
    # Generate size constants
    lines.append("    // Font sizes")
    for entry in font_entries:
        const_name = entry['var_name'].replace('font_data_', 'size_')
        lines.append(f"    static const size_t {const_name} = {entry['size']};")
    
    lines.append("")
    lines.append("    // Font info structure")
    lines.append("    struct FontInfo {")
    lines.append("        const char* name;")
    lines.append("        const unsigned char* data;")
    lines.append("        size_t size;")
    lines.append("    };")
    lines.append("")
    lines.append("    // All fonts")
    lines.append(f"    static const FontInfo AllFonts[] = {{")
    for entry in font_entries:
        lines.append(f"        {{ \"{entry['name']}\", {entry['var_name']}, {entry['var_name'].replace('font_data_', 'size_')} }},")
    lines.append("    };")
    lines.append("")
    lines.append(f"    static const size_t FontCount = {len(font_entries)};")
    lines.append("")
    
    # Generate helper function to find font by name
    lines.append("    // Find font by name (returns nullptr if not found)")
    lines.append("    inline const FontInfo* FindFont(const char* name) {")
    lines.append("        for (size_t i = 0; i < FontCount; ++i) {")
    lines.append("            // Simple name comparison (case-sensitive)")
    lines.append("            const char* a = AllFonts[i].name;")
    lines.append("            const char* b = name;")
    lines.append("            while (*a && *b && *a == *b) { a++; b++; }")
    lines.append("            if (*a == '\\0' && *b == '\\0') return &AllFonts[i];")
    lines.append("        }")
    lines.append("        return nullptr;")
    lines.append("    }")
    lines.append("")
    
    lines.append("} // namespace " + namespace)
    lines.append("")
    lines.append("#endif // EMBEDDED_FONTS_H")
    
    # Write the header file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    print(f"\nGenerated: {output_file}")
    print(f"Total fonts: {len(font_entries)}")


def main():
    parser = argparse.ArgumentParser(
        description="Convert TTF fonts to embeddable C/C++ header"
    )
    parser.add_argument(
        '--input', '-i',
        type=str,
        default='../fonts',
        help='Input directory containing TTF files (default: ../fonts)'
    )
    parser.add_argument(
        '--output', '-o',
        type=str,
        default='../ui/embedded_fonts.h',
        help='Output header file path (default: ../ui/embedded_fonts.h)'
    )
    parser.add_argument(
        '--namespace', '-n',
        type=str,
        default='EmbeddedFonts',
        help='C++ namespace for the embedded fonts (default: EmbeddedFonts)'
    )
    
    args = parser.parse_args()
    
    fonts_dir = Path(args.input).resolve()
    output_file = Path(args.output).resolve()
    
    if not fonts_dir.exists():
        print(f"Error: Input directory '{fonts_dir}' does not exist")
        return 1
    
    # Create output directory if needed
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    generate_header(fonts_dir, output_file, args.namespace)
    return 0


if __name__ == "__main__":
    exit(main())
