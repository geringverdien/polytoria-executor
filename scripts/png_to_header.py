#!/usr/bin/env python3
"""
PNG to Embeddable C/C++ Header Converter

This script converts all .png icon files in a specified directory
into a single embeddable C/C++ header file for use with Dear ImGui.
It generates RGBA pixel data that can be directly uploaded to a GPU texture.

Usage:
    python png_to_header.py [--input <icons_dir>] [--output <output_header.h>]

Example:
    python png_to_header.py --input ../icons_png --output ../ui/embedded_icons.h
"""

import os
import argparse
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    print("Error: Pillow is required. Install with: pip install Pillow")
    exit(1)


def png_to_c_array(file_path: Path) -> tuple[str, int, int, list[int]]:
    """
    Read a PNG file and convert it to RGBA pixel data.
    
    Args:
        file_path: Path to the PNG file
        
    Returns:
        Tuple of (variable_name, width, height, pixel_array)
        pixel_array is in RGBA format (4 bytes per pixel)
    """
    img = Image.open(file_path)
    
    # Convert to RGBA if necessary
    if img.mode != 'RGBA':
        img = img.convert('RGBA')
    
    width, height = img.size
    pixels = list(img.getdata())
    
    # Flatten to RGBA byte array
    pixel_data = []
    for pixel in pixels:
        pixel_data.extend(pixel)  # R, G, B, A
    
    # Create variable name from filename (sanitize for C)
    var_name = file_path.stem.replace('-', '_').replace(' ', '_')
    var_name = f"icon_data_{var_name}"
    
    return var_name, width, height, pixel_data


def generate_header(icons_dir: Path, output_file: Path, namespace: str = "EmbeddedIcons"):
    """
    Generate a C/C++ header file containing all PNG icons as embedded RGBA data.
    
    Args:
        icons_dir: Directory containing PNG files
        output_file: Output header file path
        namespace: C++ namespace to use
    """
    png_files = sorted(icons_dir.glob("*.png"))
    
    if not png_files:
        print(f"No PNG files found in {icons_dir}")
        return
    
    lines = []
    lines.append("// Auto-generated by png_to_header.py")
    lines.append("// DO NOT EDIT MANUALLY")
    lines.append("")
    lines.append("#ifndef EMBEDDED_ICONS_H")
    lines.append("#define EMBEDDED_ICONS_H")
    lines.append("")
    lines.append("#include <cstdint>")
    lines.append("#include <cstddef>")
    lines.append("")
    lines.append(f"namespace {namespace}")
    lines.append("{")
    
    icon_entries = []
    
    for png_file in png_files:
        var_name, width, height, pixel_data = png_to_c_array(png_file)
        icon_name = png_file.stem
        
        print(f"Processing: {png_file.name} ({width}x{height}, {len(pixel_data)} bytes)")
        
        # Generate the array
        lines.append(f"    // Icon: {icon_name}")
        lines.append(f"    // Dimensions: {width}x{height}")
        lines.append(f"    // Size: {len(pixel_data)} bytes (RGBA)")
        lines.append(f"    static const unsigned char {var_name}[] = {{")
        
        # Format bytes with proper indentation
        bytes_per_line = 16
        for i in range(0, len(pixel_data), bytes_per_line):
            chunk = pixel_data[i:i + bytes_per_line]
            hex_values = ", ".join(f"0x{b:02x}" for b in chunk)
            if i + bytes_per_line < len(pixel_data):
                hex_values += ","
            lines.append(f"        {hex_values}")
        
        lines.append("    };")
        lines.append("")
        
        # Store entry info
        icon_entries.append({
            'name': icon_name,
            'var_name': var_name,
            'width': width,
            'height': height,
            'size': len(pixel_data)
        })
    
    # Generate dimension constants
    lines.append("    // Icon dimensions")
    for entry in icon_entries:
        const_name_w = entry['var_name'].replace('icon_data_', 'icon_') + "_width"
        const_name_h = entry['var_name'].replace('icon_data_', 'icon_') + "_height"
        lines.append(f"    static const int {const_name_w} = {entry['width']};")
        lines.append(f"    static const int {const_name_h} = {entry['height']};")
    
    lines.append("")
    lines.append("    // Icon info structure")
    lines.append("    struct IconInfo {")
    lines.append("        const char* name;")
    lines.append("        const unsigned char* data;")
    lines.append("        int width;")
    lines.append("        int height;")
    lines.append("    };")
    lines.append("")
    lines.append("    // All icons")
    lines.append(f"    static const IconInfo AllIcons[] = {{")
    for entry in icon_entries:
        lines.append(f"        {{ \"{entry['name']}\", {entry['var_name']}, {entry['var_name'].replace('icon_data_', 'icon_')}_width, {entry['var_name'].replace('icon_data_', 'icon_')}_height }},")
    lines.append("    };")
    lines.append("")
    lines.append(f"    static const size_t IconCount = {len(icon_entries)};")
    lines.append("")
    
    # Generate helper function to find icon by name
    lines.append("    // Find icon by name (returns nullptr if not found)")
    lines.append("    inline const IconInfo* FindIcon(const char* name) {")
    lines.append("        for (size_t i = 0; i < IconCount; ++i) {")
    lines.append("            // Simple name comparison (case-sensitive)")
    lines.append("            const char* a = AllIcons[i].name;")
    lines.append("            const char* b = name;")
    lines.append("            while (*a && *b && *a == *b) { a++; b++; }")
    lines.append("            if (*a == '\\0' && *b == '\\0') return &AllIcons[i];")
    lines.append("        }")
    lines.append("        return nullptr;")
    lines.append("    }")
    lines.append("")
    
    # Generate texture atlas helper
    lines.append("    // Helper to create a texture atlas for all icons")
    lines.append("    // Returns total width, height needed for a simple horizontal atlas")
    lines.append("    inline void GetAtlasDimensions(int* outWidth, int* outHeight) {")
    lines.append("        int totalWidth = 0;")
    lines.append("        int maxHeight = 0;")
    lines.append("        for (size_t i = 0; i < IconCount; ++i) {")
    lines.append("            totalWidth += AllIcons[i].width;")
    lines.append("            if (AllIcons[i].height > maxHeight) maxHeight = AllIcons[i].height;")
    lines.append("        }")
    lines.append("        *outWidth = totalWidth;")
    lines.append("        *outHeight = maxHeight;")
    lines.append("    }")
    lines.append("")
    
    lines.append("} // namespace " + namespace)
    lines.append("")
    lines.append("#endif // EMBEDDED_ICONS_H")
    
    # Write the header file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    print(f"\nGenerated: {output_file}")
    print(f"Total icons: {len(icon_entries)}")


def main():
    parser = argparse.ArgumentParser(
        description="Convert PNG icons to embeddable C/C++ header"
    )
    parser.add_argument(
        '--input', '-i',
        type=str,
        default='../icons_png',
        help='Input directory containing PNG files (default: ../icons_png)'
    )
    parser.add_argument(
        '--output', '-o',
        type=str,
        default='../ui/embedded_icons.h',
        help='Output header file path (default: ../ui/embedded_icons.h)'
    )
    parser.add_argument(
        '--namespace', '-n',
        type=str,
        default='EmbeddedIcons',
        help='C++ namespace for the embedded icons (default: EmbeddedIcons)'
    )
    
    args = parser.parse_args()
    
    icons_dir = Path(args.input).resolve()
    output_file = Path(args.output).resolve()
    
    if not icons_dir.exists():
        print(f"Error: Input directory '{icons_dir}' does not exist")
        return 1
    
    # Create output directory if needed
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    generate_header(icons_dir, output_file, args.namespace)
    return 0


if __name__ == "__main__":
    exit(main())
